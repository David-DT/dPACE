const Hasher = require('./lib/hasher.js');
const PrivateKey = require('./lib/privateKey.js');
const Prng = require('./lib/prng.js');
const Web3 = require('web3');

const assert = require('assert');
const elliptic = require('elliptic'); //Added alt_bn128 curve for this to work.

const hasher = new Hasher();
const prng = new Prng();
const web3 = new Web3();

//PrivateKey needs to be generated by multpilying real private key, with accessToken
const msg = 'one ring to rule them all!';
const key = new PrivateKey(prng.random, hasher);
console.log("Public key of key:", key.public_key.point.x);

//Check whether, keys are created correctly -> in the end, we will need to generate one-time secret key
const foreign_keys = [new PrivateKey(prng.random, hasher).public_key,
    new PrivateKey(prng.random, hasher).public_key];
    
// Checks whether correct signature happened
const signature = key.sign(msg,foreign_keys);
const public_key = signature.public_key;
console.log(signature.verify(msg,public_key));
//Inputs for RingSign function:
console.log("Private Key used in signature", key.value);
console.log("Public Key x:", web3.utils.toHex(key.public_key.point.x))
console.log("Public Key y:", web3.utils.toHex(key.public_key.point.y))
console.log("random numbers:",prng.random);
console.log("random numbers:",prng.random);
console.log("Mix-in public key 1 (x):", web3.utils.toHex(foreign_keys[0].point.x));
console.log("Mix-in public key 1 (y):", web3.utils.toHex(foreign_keys[0].point.y));
console.log("Mix-in public key 2 (x):", web3.utils.toHex(foreign_keys[1].point.x));
console.log("Mix-in public keys 2 (y):", web3.utils.toHex(foreign_keys[1].point.y));
