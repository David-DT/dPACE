const Hasher = require('./lib/hasher.js');
const PrivateKey = require('./lib/privateKey.js');
const Prng = require('./lib/prng.js');
const Web3 = require('web3');

const assert = require('assert');
const elliptic = require('elliptic'); //Added alt_bn128 curve for this to work.

const hasher = new Hasher();
const prng = new Prng();
const web3 = new Web3();

//PrivateKey needs to be generated by multpilying real private key, with accessToken
const msg = 'one ring to rule them all!';
const key = new PrivateKey(prng.random, hasher);

console.log("Public Key X", web3.utils.toHex(key.public_key.point.x));
console.log("Public Key y", web3.utils.toHex(key.public_key.point.y));
console.log("Corresponding Private Key", key.value);


console.log("random nr1:", prng.random);
console.log("random nr2:", prng.random);
//Check whether, keys are created correctly -> in the end, we will need to generate one-time secret key
const foreign_keys = [new PrivateKey(prng.random, hasher).public_key,
    new PrivateKey(prng.random, hasher).public_key];
    
console.log("Compressed public key 1 (x):", web3.utils.toHex(foreign_keys[0].point.x));
console.log("Compressed public key 1 (y):", web3.utils.toHex(foreign_keys[0].point.y));
console.log("Compressed public key 2 (x):", web3.utils.toHex(foreign_keys[1].point.x));
console.log("Compressed public keys 2 (y):", web3.utils.toHex(foreign_keys[1].point.y));
// Checks whether correct signature happened
const signature = key.sign(msg,foreign_keys);
const public_key = signature.public_key;
console.log(signature.verify(msg,public_key));
