const Hasher = require('./lib/hasher.js');
const PrivateKey = require('./lib/privateKey.js');
const Prng = require('./lib/prng.js');
const Web3 = require('web3');

const assert = require('assert');
const elliptic = require('elliptic');

const hasher = new Hasher();
const prng = new Prng();
const web3 = new Web3();

console.log("Order", web3.utils.toHex('21888242871839275222246405745257275088548364400416034343698204186575808495617'));
//PrivateKey needs to be generated by multpilying real private key, with accessToken
const msg = 'one ring to rule them all!';
const key = new PrivateKey(prng.random, hasher);

console.log("Check public keys:", key.public_keys)
//Check whether, keys are created correctly -> in the end, we will need to generate one-time secret key
console.log("Counter after", key.counter);
const foreign_keys = [new PrivateKey(prng.random, hasher).public_keys[1],
    new PrivateKey(prng.random, hasher).public_keys[1]];
    

// Checks whether correct signature happened
const signature = key.sign(msg,foreign_keys);
const public_keys = signature.public_keys;
console.log(signature.verify(msg,public_keys));
