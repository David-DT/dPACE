const Hasher = require('./lib/hasher.js');
const PrivateKey = require('./lib/privateKey.js');
const Prng = require('./lib/prng.js');
const assert = require('assert');
const ethCrypto = require('eth-crypto');
const elliptic = require('elliptic');

const Web3 = require('web3');

const web3 = new Web3();
const hasher = new Hasher();


//console.log("Hashed Point X:", point.x.toString(10));
//console.log("Hashed Point Y:", point.y.toString(10));
//PrivateKey needs to be generated by multpilying real private key, with accessToken
const msg = 'one ring to rule them all!Sauron';

identity1 = ethCrypto.createIdentity()

const key = new PrivateKey(identity1, hasher);

//Check whether, keys are created correctly -> in the end, we will need to generate one-time secret key
/*assert.equal('0x' + key.value.toString(16),identity1.privateKey);
assert.equal(key.public_key.point.x.toString(16)+key.public_key.point.y.toString(16), identity1.publicKey.toString(16))
*/
const foreign_keys = [new PrivateKey(ethCrypto.createIdentity(),hasher).public_key,
    new PrivateKey(ethCrypto.createIdentity(),hasher).public_key];

const randomNumbers = [new Prng(), new Prng(), new Prng];

/*console.log("Compressed public key of known private:", web3.utils.hexToNumberString(key.public_key.compress()));
console.log("Private key: ", key.value.toString());

for (let i =0; i<foreign_keys.length;i++){
    console.log("I:", i, "Public keys", web3.utils.hexToNumberString(foreign_keys[i].compress()));
}

for (let i =0; i<randomNumbers.length;i++){
    console.log("I:", i, "Random Numbers", web3.utils.hexToNumberString('0x'.concat(randomNumbers[i].random)));
}
*/
// Checks whether correct signature happened
const signature = key.sign(msg,foreign_keys);
const public_keys = signature.public_keys;
console.log(signature.verify(msg,public_keys));
